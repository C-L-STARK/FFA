"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  EXTERNAL_URL_RE: () => EXTERNAL_URL_RE,
  formatDate: () => formatDate,
  formatShowDate: () => formatShowDate,
  getDefaultTitle: () => getDefaultTitle,
  getFileBirthTimeByFs: () => getFileBirthTimeByFs,
  getFileLastModifyTime: () => getFileLastModifyTime,
  getFileLastModifyTimeByFs: () => getFileLastModifyTimeByFs,
  getFileLastModifyTimeByGit: () => getFileLastModifyTimeByGit,
  getTextSummary: () => getTextSummary,
  grayMatter: () => grayMatter,
  isWindows: () => isWindows,
  joinPath: () => joinPath,
  normalizePath: () => normalizePath,
  slash: () => slash,
  withBase: () => withBase
});
module.exports = __toCommonJS(src_exports);

// src/fs.ts
var import_node_fs = __toESM(require("fs"));
var import_node_os = __toESM(require("os"));
var import_node_path = __toESM(require("path"));
var import_node_process = __toESM(require("process"));
var import_cross_spawn = require("cross-spawn");
var import_gray_matter = __toESM(require("gray-matter"));

// ../../node_modules/.pnpm/yocto-queue@1.0.0/node_modules/yocto-queue/index.js
var Node = class {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
};
var Queue = class {
  #head;
  #tail;
  #size;
  constructor() {
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (this.#head) {
      this.#tail.next = node;
      this.#tail = node;
    } else {
      this.#head = node;
      this.#tail = node;
    }
    this.#size++;
  }
  dequeue() {
    const current = this.#head;
    if (!current) {
      return;
    }
    this.#head = this.#head.next;
    this.#size--;
    return current.value;
  }
  clear() {
    this.#head = void 0;
    this.#tail = void 0;
    this.#size = 0;
  }
  get size() {
    return this.#size;
  }
  *[Symbol.iterator]() {
    let current = this.#head;
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};

// ../../node_modules/.pnpm/p-limit@4.0.0/node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve) => {
    enqueue(fn, resolve, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// src/fs.ts
var timeLimit = pLimit(+(import_node_process.default.env.P_LIMT_MAX || import_node_os.default.cpus().length));
function getDefaultTitle(content) {
  const match = content.match(/^(#+)\s+(.+)/m);
  return match?.[2] || "";
}
var cache = /* @__PURE__ */ new Map();
async function getFileLastModifyTime(url) {
  const cached = cache.get(url);
  if (cached) {
    return cached;
  }
  let date = await timeLimit(() => getFileLastModifyTimeByGit(url));
  if (!date) {
    date = await getFileLastModifyTimeByFs(url);
  }
  if (date) {
    cache.set(url, date);
  }
  return date;
}
function getFileLastModifyTimeByGit(url) {
  return new Promise((resolve) => {
    const cwd = import_node_path.default.dirname(url);
    try {
      const fileName = import_node_path.default.basename(url);
      const child = (0, import_cross_spawn.spawn)("git", ["log", "-1", '--pretty="%ai"', fileName], {
        cwd
      });
      let output = "";
      child.stdout.on("data", (d) => output += String(d));
      child.on("close", async () => {
        let date;
        if (output.trim()) {
          date = new Date(output);
        }
        resolve(date);
      });
      child.on("error", async () => {
        resolve(void 0);
      });
    } catch {
      resolve(void 0);
    }
  });
}
async function getFileBirthTimeByFs(url) {
  try {
    const fsStat = await import_node_fs.default.promises.stat(url);
    return fsStat.birthtime;
  } catch {
    return void 0;
  }
}
async function getFileLastModifyTimeByFs(url) {
  try {
    const fsStat = await import_node_fs.default.promises.stat(url);
    return fsStat.mtime;
  } catch {
    return void 0;
  }
}
var EXTERNAL_URL_RE = /^[a-z]+:/i;
function joinPath(base, path2) {
  return `${base}${path2}`.replace(/\/+/g, "/");
}
function withBase(base, path2) {
  return EXTERNAL_URL_RE.test(path2) || path2.startsWith(".") ? path2 : joinPath(base, path2);
}
var grayMatter = import_gray_matter.default;
function getTextSummary(text, count = 100) {
  return text?.replace(/^#+\s+.*/, "")?.replace(/#/g, "")?.replace(/!\[.*?\]\(.*?\)/g, "")?.replace(/\[(.*?)\]\(.*?\)/g, "$1")?.replace(/\*\*(.*?)\*\*/g, "$1")?.split("\n")?.filter((v) => !!v)?.join("\n")?.replace(/>(.*)/, "")?.replace(/</g, "&lt;").replace(/>/g, "&gt;")?.trim()?.slice(0, count);
}
var windowsSlashRE = /\\/g;
var isWindows = import_node_os.default.platform() === "win32";
function slash(p) {
  return p.replace(windowsSlashRE, "/");
}
function normalizePath(id) {
  return import_node_path.default.posix.normalize(isWindows ? slash(id) : id);
}

// src/date.ts
function formatDate(d, fmt = "yyyy-MM-dd hh:mm:ss") {
  if (!(d instanceof Date)) {
    d = new Date(d);
  }
  const o = {
    "M+": d.getMonth() + 1,
    // 月份
    "d+": d.getDate(),
    // 日
    "h+": d.getHours(),
    // 小时
    "m+": d.getMinutes(),
    // 分
    "s+": d.getSeconds(),
    // 秒
    "q+": Math.floor((d.getMonth() + 3) / 3),
    // 季度
    "S": d.getMilliseconds()
    // 毫秒
  };
  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(
      RegExp.$1,
      `${d.getFullYear()}`.substr(4 - RegExp.$1.length)
    );
  }
  for (const k in o) {
    if (new RegExp(`(${k})`).test(fmt))
      fmt = fmt.replace(
        RegExp.$1,
        RegExp.$1.length === 1 ? o[k] : `00${o[k]}`.substr(`${o[k]}`.length)
      );
  }
  return fmt;
}
function formatShowDate(date) {
  const source = +new Date(date);
  const now = +/* @__PURE__ */ new Date();
  const diff = now - source;
  const oneSeconds = 1e3;
  const oneMinute = oneSeconds * 60;
  const oneHour = oneMinute * 60;
  const oneDay = oneHour * 24;
  const oneWeek = oneDay * 7;
  if (diff < oneMinute) {
    return `${Math.floor(diff / oneSeconds)}\u79D2\u524D`;
  }
  if (diff < oneHour) {
    return `${Math.floor(diff / oneMinute)}\u5206\u949F\u524D`;
  }
  if (diff < oneDay) {
    return `${Math.floor(diff / oneHour)}\u5C0F\u65F6\u524D`;
  }
  if (diff < oneWeek) {
    return `${Math.floor(diff / oneDay)}\u5929\u524D`;
  }
  return formatDate(new Date(date), "yyyy-MM-dd");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EXTERNAL_URL_RE,
  formatDate,
  formatShowDate,
  getDefaultTitle,
  getFileBirthTimeByFs,
  getFileLastModifyTime,
  getFileLastModifyTimeByFs,
  getFileLastModifyTimeByGit,
  getTextSummary,
  grayMatter,
  isWindows,
  joinPath,
  normalizePath,
  slash,
  withBase
});
